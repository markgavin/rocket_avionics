#tag Module
Protected Module Module_Navigation
	#tag Method, Flags = &h0
		Function CalculateDistanceM(inLat1 As Double, inLon1 As Double, inLat2 As Double, inLon2 As Double) As Double
		  // Haversine formula for great-circle distance
		  // Returns distance in meters

		  Const kEarthRadiusM As Double = 6371000.0
		  Const kDegToRad As Double = 0.01745329252

		  Var theLat1Rad As Double = inLat1 * kDegToRad
		  Var theLat2Rad As Double = inLat2 * kDegToRad
		  Var theDeltaLat As Double = (inLat2 - inLat1) * kDegToRad
		  Var theDeltaLon As Double = (inLon2 - inLon1) * kDegToRad

		  Var theA As Double = Sin(theDeltaLat / 2) * Sin(theDeltaLat / 2) + _
		  Cos(theLat1Rad) * Cos(theLat2Rad) * Sin(theDeltaLon / 2) * Sin(theDeltaLon / 2)

		  Var theC As Double = 2 * ATan2(Sqrt(theA), Sqrt(1 - theA))

		  Return kEarthRadiusM * theC
		End Function
	#tag EndMethod

	#tag Method, Flags = &h0
		Function CalculateBearingDeg(inLat1 As Double, inLon1 As Double, inLat2 As Double, inLon2 As Double) As Double
		  // Calculate initial bearing from point 1 to point 2
		  // Returns bearing in degrees (0-360, 0 = North)

		  Const kDegToRad As Double = 0.01745329252
		  Const kRadToDeg As Double = 57.29577951

		  Var theLat1Rad As Double = inLat1 * kDegToRad
		  Var theLat2Rad As Double = inLat2 * kDegToRad
		  Var theDeltaLon As Double = (inLon2 - inLon1) * kDegToRad

		  Var theY As Double = Sin(theDeltaLon) * Cos(theLat2Rad)
		  Var theX As Double = Cos(theLat1Rad) * Sin(theLat2Rad) - _
		  Sin(theLat1Rad) * Cos(theLat2Rad) * Cos(theDeltaLon)

		  Var theBearing As Double = ATan2(theY, theX) * kRadToDeg

		  // Normalize to 0-360
		  If theBearing < 0 Then
		    theBearing = theBearing + 360.0
		  End If

		  Return theBearing
		End Function
	#tag EndMethod

	#tag Method, Flags = &h0
		Function BearingToCompass(inBearing As Double) As String
		  // Convert bearing to compass direction
		  // Returns "N", "NE", "E", "SE", "S", "SW", "W", "NW"

		  // Normalize bearing
		  Var theBearing As Double = inBearing
		  While theBearing < 0
		    theBearing = theBearing + 360
		  Wend
		  While theBearing >= 360
		    theBearing = theBearing - 360
		  Wend

		  // 8 compass directions at 45 degree intervals
		  // N = 337.5 to 22.5, NE = 22.5 to 67.5, etc.
		  Var theIndex As Integer = Round(theBearing / 45.0)
		  If theIndex >= 8 Then theIndex = 0

		  Select Case theIndex
		  Case 0
		    Return "N"
		  Case 1
		    Return "NE"
		  Case 2
		    Return "E"
		  Case 3
		    Return "SE"
		  Case 4
		    Return "S"
		  Case 5
		    Return "SW"
		  Case 6
		    Return "W"
		  Case 7
		    Return "NW"
		  Else
		    Return "N"
		  End Select
		End Function
	#tag EndMethod

	#tag Method, Flags = &h0
		Function FormatDistance(inMeters As Double) As String
		  // Format distance for display
		  // Returns string like "1,234 m" or "1.2 km"

		  If inMeters < 1000 Then
		    Var theInt As Integer = Round(inMeters)
		    Return Str(theInt) + " m"
		  Else
		    Var theKm As Double = inMeters / 1000.0
		    Return Str(Round(theKm * 10) / 10) + " km"
		  End If
		End Function
	#tag EndMethod

	#tag Method, Flags = &h0
		Function FormatBearing(inBearing As Double) As String
		  // Format bearing for display
		  // Returns string like "NE 47 deg"

		  Var theCompass As String = BearingToCompass(inBearing)
		  Var theDeg As Integer = Round(inBearing)
		  Return theCompass + " " + Str(theDeg) + Chr(&hB0)  // degree symbol
		End Function
	#tag EndMethod

	#tag Method, Flags = &h0
		Function FormatCoordinate(inDegrees As Double, inIsLatitude As Boolean) As String
		  // Format coordinate for display
		  // Returns string like "38.897957 deg N" or "-77.036560 deg W"

		  Var theDirection As String
		  Var theValue As Double = Abs(inDegrees)

		  If inIsLatitude Then
		    If inDegrees >= 0 Then
		      theDirection = "N"
		    Else
		      theDirection = "S"
		    End If
		  Else
		    If inDegrees >= 0 Then
		      theDirection = "E"
		    Else
		      theDirection = "W"
		    End If
		  End If

		  Return Str(Round(theValue * 1000000) / 1000000) + Chr(&hB0) + " " + theDirection
		End Function
	#tag EndMethod


	#tag DelegateDeclaration, Flags = &h21
		Private Delegate Sub MenuActionDelegate(inAction As Ptr)
	#tag EndDelegateDeclaration

	#tag Method, Flags = &h0
		Sub ApplyDarkModeColors(inScreen As MobileScreen)
		  // Set screen and subview backgrounds to iOS system colors that adapt to dark mode.
		  // Without this, hardcoded colors don't adapt to the current appearance.

		  If inScreen = Nil Then Return

		  Declare Function NSClassFromString Lib "Foundation" (name As CFStringRef) As Ptr
		  Declare Function systemGroupedBackgroundColor Lib "UIKit" Selector "systemGroupedBackgroundColor" (cls As Ptr) As Ptr
		  Declare Function clearColor Lib "UIKit" Selector "clearColor" (cls As Ptr) As Ptr
		  Declare Sub setBackgroundColor Lib "UIKit" Selector "setBackgroundColor:" (obj As Ptr, color As Ptr)
		  Declare Function isKindOfClass Lib "Foundation" Selector "isKindOfClass:" (obj As Ptr, cls As Ptr) As Boolean
		  Declare Function subviews Lib "UIKit" Selector "subviews" (obj As Ptr) As Ptr
		  Declare Function count Lib "Foundation" Selector "count" (obj As Ptr) As UInteger
		  Declare Function objectAtIndex Lib "Foundation" Selector "objectAtIndex:" (obj As Ptr, index As UInteger) As Ptr

		  Var theUIColorClass As Ptr = NSClassFromString("UIColor")
		  If theUIColorClass = Nil Then Return

		  Var theBgColor As Ptr = systemGroupedBackgroundColor(theUIColorClass)
		  Var theClearColor As Ptr = clearColor(theUIColorClass)

		  // Set screen background
		  setBackgroundColor(inScreen.Handle, theBgColor)

		  // Walk immediate subviews and fix UITableView backgrounds
		  Var theUITableViewClass As Ptr = NSClassFromString("UITableView")
		  Var theSubviews As Ptr = subviews(inScreen.Handle)
		  If theSubviews = Nil Then Return

		  Var theCount As UInteger = count(theSubviews)
		  For i As UInteger = 0 To theCount - 1
		    Var theSubview As Ptr = objectAtIndex(theSubviews, i)
		    If isKindOfClass(theSubview, theUITableViewClass) Then
		      setBackgroundColor(theSubview, theClearColor)
		    End If
		  Next
		End Sub
	#tag EndMethod

	#tag Method, Flags = &h0
		Sub SetLabelSystemColor(inLabelHandle As Ptr, inIsSecondary As Boolean)
		  // Set a UILabel's text color to the iOS system adaptive label color.
		  // Primary = labelColor (black in light, white in dark)
		  // Secondary = secondaryLabelColor (dimmer in both modes)

		  If inLabelHandle = Nil Then Return

		  Declare Function NSClassFromString Lib "Foundation" (name As CFStringRef) As Ptr
		  Declare Function labelColor Lib "UIKit" Selector "labelColor" (cls As Ptr) As Ptr
		  Declare Function secondaryLabelColor Lib "UIKit" Selector "secondaryLabelColor" (cls As Ptr) As Ptr
		  Declare Sub setTextColor Lib "UIKit" Selector "setTextColor:" (obj As Ptr, color As Ptr)

		  Var theUIColorClass As Ptr = NSClassFromString("UIColor")
		  If theUIColorClass = Nil Then Return

		  If inIsSecondary Then
		    setTextColor(inLabelHandle, secondaryLabelColor(theUIColorClass))
		  Else
		    setTextColor(inLabelHandle, labelColor(theUIColorClass))
		  End If
		End Sub
	#tag EndMethod

	#tag Method, Flags = &h0
		Sub SetupMenuButton(inScreen As MobileScreen)
		  // Creates a native iOS pull-down UIMenu on the navigation bar "..." button.
		  // Strategy: Create UIBarButtonItem entirely via declares with no target/action.
		  // UIKit shows the menu on single tap when a bar button has a menu but no action.
		  // This avoids Xojo's MobileToolbarButton which sets its own action handler
		  // that interferes with menu display after navigation push/pop.

		  If inScreen = Nil Then Return

		  // Apply dark mode system colors to screen background
		  ApplyDarkModeColors(inScreen)

		  pMenuScreen = inScreen
		  If inScreen IsA Screen_Main Then
		    pMainScreen = inScreen
		  End If

		  // Step 1: Walk responder chain from UIView to find UIViewController
		  Var theViewHandle As Ptr = inScreen.Handle
		  If theViewHandle = Nil Then Return

		  Declare Function NSClassFromString Lib "Foundation" (name As CFStringRef) As Ptr
		  Declare Function nextResponder Lib "UIKit" Selector "nextResponder" (obj As Ptr) As Ptr
		  Declare Function isKindOfClass Lib "Foundation" Selector "isKindOfClass:" (obj As Ptr, cls As Ptr) As Boolean

		  Var theUIVCClass As Ptr = NSClassFromString("UIViewController")
		  Var theResponder As Ptr = nextResponder(theViewHandle)
		  While theResponder <> Nil
		    If isKindOfClass(theResponder, theUIVCClass) Then
		      Exit
		    End If
		    theResponder = nextResponder(theResponder)
		  Wend
		  If theResponder = Nil Then Return

		  // Step 2: Get navigationItem from the UIViewController
		  Declare Function navigationItem Lib "UIKit" Selector "navigationItem" (obj As Ptr) As Ptr
		  Var theNavItem As Ptr = navigationItem(theResponder)
		  If theNavItem = Nil Then Return

		  // Step 3: Build UIMenu via declares
		  Var theUIImageClass As Ptr = NSClassFromString("UIImage")
		  Var theUIActionClass As Ptr = NSClassFromString("UIAction")
		  Var theUIMenuClass As Ptr = NSClassFromString("UIMenu")
		  Var theNSArrayClass As Ptr = NSClassFromString("NSArray")
		  Var theUIBarButtonItemClass As Ptr = NSClassFromString("UIBarButtonItem")

		  Declare Function systemImageNamed Lib "UIKit" Selector "systemImageNamed:" (cls As Ptr, name As CFStringRef) As Ptr

		  Var theConnected As Boolean = App.pConnection <> Nil And App.pConnection.IsConnected
		  Var theConnectIconName As String
		  Var theConnectTitle As String
		  If theConnected Then
		    theConnectIconName = "wifi.slash"
		    theConnectTitle = "Disconnect"
		  Else
		    theConnectIconName = "wifi"
		    theConnectTitle = "Connect"
		  End If

		  Var theHomeIcon As Ptr = systemImageNamed(theUIImageClass, "house")
		  Var theConnectIcon As Ptr = systemImageNamed(theUIImageClass, theConnectIconName)
		  Var theSettingsIcon As Ptr = systemImageNamed(theUIImageClass, "gearshape")
		  Var theRecoveryIcon As Ptr = systemImageNamed(theUIImageClass, "location.fill")
		  Var theFlightDataIcon As Ptr = systemImageNamed(theUIImageClass, "externaldrive")
		  Var theAboutIcon As Ptr = systemImageNamed(theUIImageClass, "info.circle")

		  // Create handler block once and reuse — if replaced, the old block gets GC'd
		  // which invalidates menu handlers on previously-setup screens
		  If pActionBlock = Nil Then
		    Var theDelegate As MenuActionDelegate = AddressOf HandleMenuAction
		    pActionBlock = New ObjCBlock(theDelegate)
		  End If

		  // Create UIAction items
		  Declare Function actionWithTitle Lib "UIKit" Selector "actionWithTitle:image:identifier:handler:" (cls As Ptr, title As CFStringRef, image As Ptr, identifier As Ptr, handler As Ptr) As Ptr

		  Var theAction0 As Ptr = actionWithTitle(theUIActionClass, "Home", theHomeIcon, Nil, pActionBlock.Handle)
		  Var theAction1 As Ptr = actionWithTitle(theUIActionClass, theConnectTitle, theConnectIcon, Nil, pActionBlock.Handle)
		  Var theAction2 As Ptr = actionWithTitle(theUIActionClass, "Settings", theSettingsIcon, Nil, pActionBlock.Handle)
		  Var theAction3 As Ptr = actionWithTitle(theUIActionClass, "Recovery", theRecoveryIcon, Nil, pActionBlock.Handle)
		  Var theAction4 As Ptr = actionWithTitle(theUIActionClass, "Flight Data", theFlightDataIcon, Nil, pActionBlock.Handle)
		  Var theAction5 As Ptr = actionWithTitle(theUIActionClass, "About", theAboutIcon, Nil, pActionBlock.Handle)

		  Declare Function arrayWithObjects Lib "Foundation" Selector "arrayWithObjects:count:" (cls As Ptr, objects As Ptr, count As UInteger) As Ptr
		  Var theActionPtrs As New MemoryBlock(6 * 8)
		  theActionPtrs.Ptr(0) = theAction0
		  theActionPtrs.Ptr(8) = theAction1
		  theActionPtrs.Ptr(16) = theAction2
		  theActionPtrs.Ptr(24) = theAction3
		  theActionPtrs.Ptr(32) = theAction4
		  theActionPtrs.Ptr(40) = theAction5
		  Var theActions As Ptr = arrayWithObjects(theNSArrayClass, theActionPtrs, 6)

		  // Create UIMenu
		  Declare Function menuWithTitle Lib "UIKit" Selector "menuWithTitle:children:" (cls As Ptr, title As CFStringRef, children As Ptr) As Ptr
		  Var theMenu As Ptr = menuWithTitle(theUIMenuClass, "", theActions)

		  // Step 4: Create UIBarButtonItem via declares with NO target/action
		  // UIKit shows the menu on single tap when there is no action set
		  Var theEllipsisImage As Ptr = systemImageNamed(theUIImageClass, "ellipsis.circle")

		  Declare Function alloc Lib "Foundation" Selector "alloc" (cls As Ptr) As Ptr
		  Declare Function initWithImageStyleTargetAction Lib "UIKit" Selector "initWithImage:style:target:action:" (obj As Ptr, image As Ptr, style As Integer, target As Ptr, action As Ptr) As Ptr

		  Var theBarButton As Ptr = initWithImageStyleTargetAction(alloc(theUIBarButtonItemClass), theEllipsisImage, 0, Nil, Nil)

		  // Attach menu to the button
		  Declare Sub setMenu Lib "UIKit" Selector "setMenu:" (obj As Ptr, menu As Ptr)
		  setMenu(theBarButton, theMenu)

		  // Step 5: Set as right bar button item on the navigation item
		  Var theButtonPtrs As New MemoryBlock(8)
		  theButtonPtrs.Ptr(0) = theBarButton
		  Var theButtonArray As Ptr = arrayWithObjects(theNSArrayClass, theButtonPtrs, 1)

		  Declare Sub setRightBarButtonItems Lib "UIKit" Selector "setRightBarButtonItems:" (obj As Ptr, items As Ptr)
		  setRightBarButtonItems(theNavItem, theButtonArray)
		End Sub
	#tag EndMethod

	#tag Method, Flags = &h21
		Private Sub HandleMenuAction(inAction As Ptr)
		  // Route menu selection by reading the UIAction's title.
		  // Defers the actual navigation to the Xojo event loop via Timer.CallLater
		  // because PushTo may not work reliably from an ObjC block callback.
		  If inAction = Nil Then Return

		  Try
		    Declare Function title Lib "UIKit" Selector "title" (obj As Ptr) As CFStringRef
		    pPendingMenuAction = title(inAction)
		    Timer.CallLater(0, AddressOf ExecuteMenuAction)
		  Catch theError As RuntimeException
		    System.DebugLog("HandleMenuAction error: " + theError.Message)
		  End Try
		End Sub
	#tag EndMethod

	#tag Method, Flags = &h21
		Private Sub ExecuteMenuAction()
		  // Execute the deferred menu action on the Xojo event loop.
		  // Always pops to root first before pushing a new screen. This ensures
		  // previous screens get their Closing events and clean up AddHandler
		  // registrations. Without this, stacked screens with AddHandler on
		  // shared objects (App.pConnection) cause "already handled" crashes
		  // when a second instance of the same screen type is pushed.
		  Var theTitle As String = pPendingMenuAction
		  pPendingMenuAction = ""

		  If theTitle = "" Then Return
		  If pMainScreen = Nil Then Return

		  Try
		    // For screen navigation, pop to root first (without animation) to
		    // clean up the stack and fire Closing events on pushed screens
		    Select Case theTitle
		    Case "Connect", "Disconnect"
		      // Non-navigation actions — don't pop

		    Else
		      // Pop to root without animation so Closing fires on stacked screens
		      PopToRoot(theTitle = "Home")
		      pMenuScreen = pMainScreen
		    End Select

		    Select Case theTitle
		    Case "Home"
		      // Already popped to root above (with animation)

		    Case "Connect"
		      If App.pConnection <> Nil Then
		        Var theHost As String = App.GetPreferenceString("gateway_host", "RocketGateway.local")
		        Var thePort As Integer = Val(App.GetPreferenceString("gateway_port", "5000"))
		        App.pConnection.Connect(theHost, thePort)
		      End If

		    Case "Disconnect"
		      If App.pConnection <> Nil Then
		        App.pConnection.Disconnect
		      End If

		    Case "Settings"
		      pMainScreen.PushTo(New Screen_Settings)

		    Case "Recovery"
		      pMainScreen.PushTo(New Screen_Recovery)

		    Case "Flight Data"
		      If pFlashStorageScreen = Nil Then
		        pFlashStorageScreen = New Screen_FlashStorage
		      End If
		      pMainScreen.PushTo(pFlashStorageScreen)

		    Case "About"
		      pMainScreen.PushTo(New Screen_About)
		    End Select

		  Catch theError As RuntimeException
		    System.DebugLog("ExecuteMenuAction error: " + theError.Message)
		  End Try
		End Sub
	#tag EndMethod

	#tag Method, Flags = &h21
		Private Sub PopToRoot(inAnimated As Boolean)
		  // Pop all pushed screens back to root (Main) via UINavigationController.
		  // When inAnimated is False, the pop is instant (used before pushing a new screen).
		  If pMainScreen = Nil Then Return

		  Var theViewHandle As Ptr = pMainScreen.Handle
		  If theViewHandle = Nil Then Return

		  Declare Function NSClassFromString Lib "Foundation" (name As CFStringRef) As Ptr
		  Declare Function nextResponder Lib "UIKit" Selector "nextResponder" (obj As Ptr) As Ptr
		  Declare Function isKindOfClass Lib "Foundation" Selector "isKindOfClass:" (obj As Ptr, cls As Ptr) As Boolean
		  Declare Function navigationController Lib "UIKit" Selector "navigationController" (obj As Ptr) As Ptr
		  Declare Sub popToRootViewControllerAnimated Lib "UIKit" Selector "popToRootViewControllerAnimated:" (obj As Ptr, animated As Boolean)

		  // Walk responder chain to find UIViewController
		  Var theUIVCClass As Ptr = NSClassFromString("UIViewController")
		  Var theResponder As Ptr = nextResponder(theViewHandle)
		  While theResponder <> Nil
		    If isKindOfClass(theResponder, theUIVCClass) Then
		      Exit
		    End If
		    theResponder = nextResponder(theResponder)
		  Wend

		  If theResponder <> Nil Then
		    Var theNavController As Ptr = navigationController(theResponder)
		    If theNavController <> Nil Then
		      popToRootViewControllerAnimated(theNavController, inAnimated)
		    End If
		  End If
		End Sub
	#tag EndMethod

	#tag Property, Flags = &h21
		Private pMenuScreen As MobileScreen
	#tag EndProperty

	#tag Property, Flags = &h21
		Private pMainScreen As MobileScreen
	#tag EndProperty

	#tag Property, Flags = &h21
		Private pActionBlock As ObjCBlock
	#tag EndProperty

	#tag Property, Flags = &h21
		Private pPendingMenuAction As String = ""
	#tag EndProperty

	#tag Property, Flags = &h0
		pFlashStorageScreen As Screen_FlashStorage
	#tag EndProperty


End Module
#tag EndModule
